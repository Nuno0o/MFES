class Delegation
types
	public Name = seq of char inv n == len n > 0;
values
-- TODO Define values here
instance variables
	public name: Name;
	public stocks : map Product`Type to Product`Stock;
	public customers : set of Consumer;
	public baskets : map Consumer to Basket;
	inv dom baskets subset customers and forall b in set rng baskets & dom b.products subset dom stocks;
operations
	public Delegation: seq of char ==> Delegation
	Delegation(N) == (name := N;stocks := { |-> };customers := {};baskets := { |-> };return self);
	
	--Add a product
	public addProduct: Product`Type ==> ()
	addProduct(P) == (stocks := stocks munion {P |-> 0};)
	pre P not in set(dom stocks)
	post P in set(dom stocks);
	
	--Remove a product
	public removeProduct: Product`Type ==> ()
	removeProduct(P) == (stocks := {P} <-: stocks)
	pre P in set(dom stocks) 
	post P not in set(dom stocks);
	
	--Get product list
	public getProducts: () ==> set of Product`Type
	getProducts() == (return dom stocks);
	
	--Add stock to a product
	public addProductStock: Product`Type * real ==> ()
	addProductStock(P,S) == (stocks := stocks ++ {P |-> stocks(P) + S})
	pre P in set(dom stocks) and S >= 0
	post stocks(P) >= S;
	
	--Remove stock from a product
	public removeProductStock: Product`Type * real ==> ()
	removeProductStock(P,S) == (stocks := stocks ++ {P |-> stocks(P) - S})
	pre P in set(dom stocks) and S >= 0 and S <= stocks(P)
	post stocks(P) >= 0;
	
	--Get stock of a product
	public getStock: Product`Type ==> real
	getStock(P) == (return stocks(P))
	pre P in set(dom stocks);
	
	--Make basket
	public makeBasket: Consumer ==> ()
	makeBasket(C) == (
		dcl b : Basket := new Basket(C.getBasketMaxSize()); 
		baskets := baskets munion {C |-> b}
	)
	pre C in set customers;
	
	--Fill baskets
	--public fillBaskets: () ==> ()
	--fillBaskets() == (
		--TODO
	--);
	
	--Give baskets to consumers
	public giveBaskets: () ==> ()
	giveBaskets() == (
		for all customer in set (dom baskets) do(
			customer.addBasket(baskets(customer));
		);
		baskets := { |-> };
	)
functions
	--Returns the N products with highest stock with descending order
	public highestN: map Product`Type to Product`Stock * nat -> seq of Product`Type
	highestN(P,N) == (highestNaux(P,N,[]));
	
	public highestNaux: map Product`Type to Product`Stock * nat * seq of Product`Type -> seq of Product`Type
	highestNaux(P,N,L) == if(N = 0 or P = { |-> }) then L else let c = highest(P) in highestNaux({c} <-: P, N-1, L^[c]);
	
	public highest: map Product`Type to Product`Stock -> Product`Type
	highest(P) == highestaux(P,<Manga>,-1)
	pre card dom P > 0;
	
	public highestaux: map Product`Type to Product`Stock * Product`Type * real -> Product`Type
	highestaux(P,Biggest,Max) == if(P = { |-> }) then Biggest else (let p in set dom P in if(P(p) > Max) then highestaux({p} <-: P,p,P(p)) else highestaux({p} <-: P,Biggest,Max));
traces
-- TODO Define Combinatorial Test Traces here
end Delegation