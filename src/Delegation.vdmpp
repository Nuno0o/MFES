class Delegation
types
	public Name = seq of char inv n == len n > 0;
values
-- TODO Define values here
instance variables
	public name: Name;
	public stocks : Products;
	public customers : set of Consumer;
	public baskets : map Consumer to Basket;
	inv dom baskets subset customers;
	inv forall b in set rng baskets & dom b.stocks.products subset dom stocks.products;
	inv forall c in set customers & elems c.baskets inter rng baskets = {};
operations
	public Delegation: Name ==> Delegation
	Delegation(N) == (name := N;stocks := new Products();customers := {};baskets := { |-> };return self);
	
	--Add customer
	public addCustomer: Consumer ==> ()
	addCustomer(C) == (customers := customers union {C})
	pre C not in set customers
	post C in set customers;
	
	--Remove customer
	public removeCustomer: Consumer ==> ()
	removeCustomer(C) == (customers := customers \ {C})
	pre C in set customers
	post C not in set customers;
	
	--Add a product
	public addProduct: Products`Type ==> ()
	addProduct(P) == (stocks.addProduct(P););
	
	--Remove a product
	public removeProduct: Products`Type ==> ()
	removeProduct(P) == (stocks.removeProduct(P));
	
	--Get product list
	public getProducts: () ==> set of Products`Type
	getProducts() == (return stocks.getProducts());
	
	--Add stock to a product
	public addProductStock: Products`Type * real ==> ()
	addProductStock(P,S) == (stocks.addProductStock(P,S));
	
	--Remove stock from a product
	public removeProductStock: Products`Type * real ==> ()
	removeProductStock(P,S) == (stocks.removeProductStock(P,S));
	
	--Get stock of a product
	public getStock: Products`Type ==> real
	getStock(P) == (return stocks.getStock(P));
	
	--Make basket
	public makeBasket: Consumer ==> ()
	makeBasket(C) == (
		dcl b : Basket := new Basket(C.getBasketMaxSize()); 
		baskets := baskets munion {C |-> b}
	)
	pre C in set customers;
	
	--Make baskets
	public makeBaskets: () ==> ()
	makeBaskets() == (
		for all customer in set customers do
			makeBasket(customer)
	);
	
	--Fill baskets
	public fillBaskets: () ==> ()
	fillBaskets() == (
		for all c in set customers do
			fillBasket(c);
	);
	
	--Fill basket
	public fillBasket: Consumer ==> ()
	fillBasket(C) == (
		dcl products : seq of Products`Type := highestN(stocks.products,Basket`maxNProducts(baskets(C).maxWeight));
		dcl sum : real := 0;
		for p in products do(
			sum := sum + stocks.getStock(p);
		);
		for p in products do(
			baskets(C).addProduct(p);
			stocks.removeProductStock(p,stocks.getStock(p)*baskets(C).maxWeight/sum);
			baskets(C).addProductStock(p,stocks.getStock(p)*baskets(C).maxWeight/sum);
		);
	)
	pre card dom baskets(C).stocks.products = 0 and card dom stocks.products > 0--No products are in the basket initially
	post card dom baskets(C).stocks.products > 0;
	
	--Give basket to consumer
	public giveBasket:Consumer ==> ()
	giveBasket(C) == (
		dcl B: Basket;
		B := baskets(C);
		baskets := {C} <-: baskets;
		C.addBasket(baskets(C));
	)
	pre C in set dom baskets;
	
	--Give baskets to consumers
	public giveBaskets: () ==> ()
	giveBaskets() == (
		for all customer in set (dom baskets) do(
			giveBasket(customer)
		);
		baskets := { |-> };
	)
functions
	--Returns the N products with highest stock with descending order
	public highestN: map Products`Type to Products`Stock * nat -> seq of Products`Type
	highestN(P,N) == (highestNaux(P,N,[]));
	
	public highestNaux: map Products`Type to Products`Stock * nat * seq of Products`Type -> seq of Products`Type
	highestNaux(P,N,L) == if(N = 0 or P = { |-> }) then L else let c = highest(P) in highestNaux({c} <-: P, N-1, L^[c]);
	
	public highest: map Products`Type to Products`Stock -> Products`Type
	highest(P) == highestaux(P,<Manga>,-1)
	pre card dom P > 0;
	
	public highestaux: map Products`Type to Products`Stock * Products`Type * real -> Products`Type
	highestaux(P,Biggest,Max) == if(P = { |-> }) then Biggest else (let p in set dom P in if(P(p) > Max) then highestaux({p} <-: P,p,P(p)) else highestaux({p} <-: P,Biggest,Max));

	public min: ? * ? -> ?
	min(A,B) == (if A < B then A else B);
traces
-- TODO Define Combinatorial Test Traces here
end Delegation