class Producer
types
-- TODO Define types here
values
-- TODO Define values here
instance variables
	private name : seq of char;
	private stocks : map Product`Type to real;
	private delegations : set of Delegation;
operations
	public Producer: seq of char ==> Producer
	Producer(Name) == (name := Name;stocks := { |-> };delegations := {} ; return self);
	--Get name
	public getName:() ==> seq of char
	getName() == (return name);
	
	--Add a product
	public addProduct: Product`Type ==> ()
	addProduct(P) == (stocks := stocks munion {P |-> 0};)
	pre P not in set(dom stocks)
	post P in set(dom stocks);
	
	--Remove a product
	public removeProduct: Product`Type ==> ()
	removeProduct(P) == (stocks := {P} <-: stocks)
	pre P in set(dom stocks) 
	post P not in set(dom stocks);
	
	--Get products
	public getProducts: () ==> set of Product`Type
	getProducts() == (return dom stocks);
	
	--Add stock to a product
	public addProductStock: Product`Type * real ==> ()
	addProductStock(P,S) == (stocks := stocks ++ {P |-> stocks(P) + S})
	pre P in set(dom stocks) and S >= 0
	post stocks(P) >= S;
	
	--Remove stock from a product
	public removeProductStock: Product`Type * real ==> ()
	removeProductStock(P,S) == (stocks := stocks ++ {P |-> stocks(P) - S})
	pre P in set(dom stocks) and S >= 0 and S <= stocks(P)
	post stocks(P) >= 0;
	
	--Get stock of a product
	public getStock: Product`Type ==> real
	getStock(P) == (return stocks(P))
	pre P in set(dom stocks);
	
	--Add a new delegation
	public addDelegation: Delegation ==> ()
	addDelegation(D) == (delegations := delegations union {D})
	pre D not in set delegations
	post D in set delegations;
	
	--Remove a delegation
	public removeDelegation: Delegation ==> ()
	removeDelegation(D) == (
		delegations := delegations \ {D};
	)
	pre D in set delegations
	post D not in set delegations;
	
	--Get list of delegations
	public getDelegations: () ==> set of Delegation
	getDelegations() == (return delegations);
	
	--Send product to delegation
	public sendToDelegation: Delegation * Product`Type * real ==> ()
	sendToDelegation(D,P,Q) == (
		dcl interc: set of Product`Type := D.getProducts() inter getProducts();
		if(P in set interc) then(
			D.addProductStock(P,Q);removeProductStock(P,Q);
		)
	)
	pre Q <= stocks(P);
	
	--Send products to delegations
	public sendProducts: () ==> ()
	sendProducts() == (
		dcl n : nat;--number of delegations that sell the current product
		for all product in set (dom stocks) do(
			n := 0;
			for all delegation in set delegations do (
				if(product in set delegation.getProducts()) then n:= n+1;
			);
			if(getStock(product) > 0) then(
				for all delegation in set delegations do(
					if(product in set delegation.getProducts()) then sendToDelegation(delegation,product,getStock(product) / n);
				);
				stocks := stocks ++ {product |-> 0};
			);
		);
	);
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Producer